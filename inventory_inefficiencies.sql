USE `inventory_inefficiencies_using_sql`;




-- create table
CREATE TABLE inventory_combined (
    order_data DATE,
    store_id VARCHAR(255),
    product_id VARCHAR(255),
    categories VARCHAR(255),
    region VARCHAR(255),
    inventory_level INT,
    units_sold INT,
    units_order INT,
    demand_forecast FLOAT,
    price FLOAT,
    discount INT,
    weather_condition VARCHAR(255),
    holiday_promotion BOOLEAN, 					-- Changed from holiday/promotion to holiday_promotion
    competitor_pricing FLOAT,
    seasonality VARCHAR(255)
);




-- import data using table data import wizard




-- view the data and understand the columns 
SELECT * 
FROM inventory_combined; -- composite primary key (store_id,region)




-- how many days' data
SELECT
    COUNT(DISTINCT order_data)
FROM
    inventory_combined;  -- we have 730 days data




-- total stores
WITH t AS 
    (SELECT DISTINCT store_id, region
     FROM inventory_combined)
SELECT COUNT(*)
FROM t;  -- total 20 stores




-- total products 
SELECT COUNT(DISTINCT product_id)
FROM inventory_combined;  -- 30 products




-- revenue generated by each store in each year
SELECT 
    YEAR(order_data) AS year,
    store_id,
    region,
    CONCAT(ROUND(SUM(units_sold * price) / 1000000, 2), 'M') AS `revenue_generated`
FROM inventory_combined
GROUP BY YEAR(order_data), store_id, region
ORDER BY YEAR(order_data) ASC, ROUND(SUM(units_sold * price), 2) DESC;




-- highest revenue generated by any store in each year
WITH t AS (
    SELECT 
        YEAR(order_data) AS year,
        store_id,
        region,
        CONCAT(ROUND(SUM(units_sold * price) / 1000000, 2), 'M') AS `revenue_generated`,
        RANK() OVER(PARTITION BY YEAR(order_data) ORDER BY SUM(units_sold * price) DESC) AS `rank`
    FROM inventory_combined
    GROUP BY YEAR(order_data), store_id, region
)
SELECT * 
FROM t
WHERE `rank` = 1;




-- revenue generated in each season in each year
SELECT 
    YEAR(order_data) AS year,
    seasonality,
    CONCAT(ROUND(SUM(units_sold * price) / 1000000, 2), 'M') AS `revenue_generated`,
    RANK() OVER(PARTITION BY YEAR(order_data) ORDER BY SUM(units_sold * price) DESC) AS `rank`
FROM inventory_combined
GROUP BY YEAR(order_data), seasonality
ORDER BY YEAR(order_data) ASC, SUM(units_sold * price) DESC;  -- in each year Winter has highest revenue generated followed by summer, autumn, spring




-- holiday/promotion effect
SELECT 
    holiday_promotion,
    YEAR(order_data) as year_,
    AVG(units_sold * price)  as revenue_generated
FROM inventory_combined
GROUP BY holiday_promotion, YEAR(order_data);    -- revenue/day is more when there is holiday/promotion




-- revenue generated in different weather condition in each year
SELECT 
    YEAR(order_data) AS year,
    weather_condition,
    CONCAT(ROUND(SUM(units_sold * price) / 1000000, 2), 'M') AS `revenue_generated`,
    RANK() OVER(PARTITION BY YEAR(order_data) ORDER BY SUM(units_sold * price) DESC) AS `rank`
FROM inventory_combined
GROUP BY YEAR(order_data), weather_condition
ORDER BY YEAR(order_data) ASC, SUM(units_sold * price) DESC;  -- snowy -> most revenue generated , Rainy -> least revenue generated




-- region wise revenue contribution
SELECT 
	region,
	ROUND(SUM(units_sold*price)/(SELECT SUM(units_sold*price) FROM inventory_combined),2)
FROM inventory_combined
GROUP BY region;  -- all stores contribute equally




-- Stockout Analysis: Identify how often stockouts occurred (units_sold > inventory_level)
SELECT 
	ROUND((COUNT(*)*100)/(SELECT COUNT(*) FROM inventory_combined),2)
FROM inventory_combined
WHERE units_sold > inventory_level; 




-- Overstock Analysis: Identify overstock scenarios (inventory_level > demand_forecast by a margin)
SELECT 
	ROUND((COUNT(*)*100)/(SELECT COUNT(*) FROM inventory_combined),2)
FROM inventory_combined
WHERE demand_forecast < inventory_level;  



-- Correlation Approximation: Is higher discount related to more units sold?
SELECT 
    CONCAT(discount,'%') AS discount,
    AVG(units_sold) AS avg_units_sold
FROM inventory_combined
GROUP BY discount
ORDER BY discount;




-- Best-selling Products (Overall)
SELECT 
    product_id,
    SUM(units_sold) AS total_units_sold,
    CONCAT(ROUND(SUM(units_sold * price) / 1000000, 2), 'M') AS revenue_generated
FROM inventory_combined
GROUP BY product_id
ORDER BY total_units_sold DESC
LIMIT 10;




--  Competitor Pricing vs Our Sales Performance
SELECT 
    CASE 
        WHEN price < competitor_pricing THEN 'Cheaper'
        WHEN price > competitor_pricing THEN 'Costlier'
        ELSE 'Same'
    END AS price_position,
    AVG(units_sold) AS avg_units_sold
FROM inventory_combined
GROUP BY price_position;



-- Forecast Accuracy: Difference between forecasted demand and actual sales
SELECT 
    ROUND(AVG(ABS(units_sold - demand_forecast)), 2) AS avg_absolute_error,
    ROUND(AVG(ABS(units_sold - demand_forecast) / demand_forecast) * 100, 2) AS mape_percent -- mean absolute percentage error
FROM inventory_combined;



-- Discount Effectiveness by Product Category
SELECT
    categories,
    AVG(discount) AS avg_discount,
    AVG(units_sold) AS avg_units_sold
FROM inventory_combined
GROUP BY categories
ORDER BY avg_units_sold DESC;





DELETE FROM inventory_combined
WHERE
    inventory_level < 0
    OR units_sold < 0;




-- Normalizing data

-- Stores table
DROP TABLE IF EXISTS stores;

CREATE TABLE stores (
	store_number INTEGER PRIMARY KEY,       
	store_id VARCHAR(10),
	region VARCHAR(50)
);



-- populate stores table
INSERT INTO stores(store_number,store_id,region)
SELECT 
	(CAST(SUBSTRING_INDEX(store_id,'S',-1) AS SIGNED)*100) +
    CASE
		WHEN region='East' THEN 1
        WHEN region='West' THEN 4
        WHEN region='North' THEN 2
        ELSE 3
	END AS store_number,
    store_id,
    region
FROM 
	(SELECT DISTINCT store_id,region
	FROM inventory_combined) AS unique_stores
    ORDER BY store_number;



-- Products table
DROP TABLE IF EXISTS products;

CREATE TABLE products (
    product_id VARCHAR(10) PRIMARY KEY,
    category VARCHAR(50)
);


-- populate products table
INSERT INTO products(product_id,category)
	SELECT DISTINCT product_id,categories
	FROM inventory_combined
	ORDER BY product_id;

-- day_details table
DROP TABLE IF EXISTS day_details;

CREATE TABLE day_details(
	date_ DATE PRIMARY KEY,
    seasonality VARCHAR(20)
);

-- populate dates table
INSERT INTO day_details
SELECT 	
	DISTINCT order_data,seasonality  
FROM inventory_combined;

SELECT * FROM day_details;



-- Pricing table
DROP TABLE IF EXISTS pricing;
CREATE TABLE pricing (
	order_id INTEGER PRIMARY KEY,
    price FLOAT,
    discount INTEGER,
    weather_condition VARCHAR(255),
	competitor_pricing FLOAT,
    holiday_promotion INT,
	FOREIGN KEY (order_id) REFERENCES inventory (order_id)
);
-- populating  pricing table 
INSERT INTO pricing(
	order_id ,
    price ,
    discount ,
    weather_condition ,
	competitor_pricing ,
    holiday_promotion 
	)
SELECT 
    i.order_id,
    ic.price,
    ic.discount,
    ic.weather_condition,
    ic.competitor_pricing,
    ic.holiday_promotion
FROM inventory_combined ic
JOIN stores s
  ON ic.store_id = s.store_id AND ic.region = s.region
JOIN inventory i
  ON i.date_ = ic.order_data
     AND i.store_number = s.store_number
     AND i.product_id = ic.product_id;


SELECT * FROM PRICING;

			
			

-- Inventory table
DROP TABLE IF EXISTS inventory;
CREATE TABLE inventory(
	order_id INTEGER PRIMARY KEY AUTO_INCREMENT,
    date_ DATE,
    store_number INT,
    product_id VARCHAR(255),
    inventory_level INT,
    units_sold INT,
    units_order INT,
    demand_forecast FLOAT,  
    FOREIGN KEY (date_) REFERENCES day_details(date_),
    FOREIGN KEY (store_number) REFERENCES stores(store_number),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);
ALTER TABLE inventory AUTO_INCREMENT = 100000;




-- populate inventory table
INSERT INTO 	
	inventory (
		date_,
		store_number,
		product_id,
		inventory_level ,
		units_sold ,
		units_order ,
		demand_forecast 
		)
	SELECT 
		i.order_data,
		s.store_number,
		i.product_id,
		i.inventory_level ,
		i.units_sold ,
		i.units_order ,
		i.demand_forecast
		
FROM inventory_combined i
JOIN stores s
ON i.store_id = s.store_id AND i.region = s.region;




-- calculating avg lead time
DROP TABLE IF EXISTS  lead_time_cal;
CREATE TABLE lead_time_cal (
    store_number INTEGER ,
    product_id VARCHAR(255),
    avg_lead_time_days FLOAT,
    PRIMARY KEY (store_number, product_id),
    FOREIGN KEY (store_number) REFERENCES stores(store_number),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);



-- indexing to optimize INSERT INTO lead_time_cal
CREATE INDEX idx_inventory_main 
ON inventory(store_number, product_id, date_);



-- calculating lead time
SELECT * FROM lead_time_cal;
INSERT INTO lead_time_cal(
	store_number ,
    product_id,
    avg_lead_time_days
	)
WITH ordered_days AS (
	SELECT 
		date_,
		store_number,
		product_id,
		units_order
    FROM inventory
    WHERE units_order>0
),
cal AS (
	SELECT 
		o.date_ AS ordered_date,
        d.date_ AS delivered_date,
        o.store_number,
        d.inventory_level,
		o.product_id,
		o.units_order,
        d.inventory_level  - LAG(d.inventory_level) OVER(PARTITION BY d.store_number, d.product_id 
		ORDER BY d.date_ ) AS inventory_change
    FROM ordered_days o
    JOIN  inventory d
    ON o.store_number = d.store_number
		AND o.product_id = d.product_id
        AND d.date_ BETWEEN o.date_ AND DATE_ADD(o.date_, INTERVAL 7 DAY)
	)
SELECT  store_number,
		product_id,
        ROUND(AVG(DATEDIFF(delivered_date,ordered_date)),2) AS avg_lead_time_days
FROM cal
WHERE inventory_change >= 0.8*units_order -- Percentage to consider as delivered - (70-90)% - cosidering 80% here
GROUP BY cal.store_number,cal.product_id;


SELECT * FROM lead_time_cal;


-- safety stock ( assuming 95% service level , Z  = 1.65)
-- Safety Stock = (Max Daily Usage × Max Lead Time) - (Average Daily Usage × Average Lead Time).  -[when you don't know std dev of your data]
-- in our case avg lead time is stable and demand is uncertain so [Safety Stock = Z × σD × √(avg Lead Time in days)] is perfect to use , σD = Standard deviation of daily demand
ALTER TABLE lead_time_cal
ADD COLUMN safety_stock FLOAT;

WITH t AS (
SELECT 
    i.product_id,
    i.store_number,
    p.avg_lead_time_days ,
    ROUND(STDDEV(i.units_sold) ,2) AS demand_std,
    ROUND(STDDEV(i.units_sold) * SQRT(p.avg_lead_time_days) * 1.65, 2) AS safety_stock 
FROM inventory as i
JOIN lead_time_cal as p
ON i.product_id = p.product_id AND i.store_number = p.store_number
GROUP BY i.product_id , i.store_number, p.avg_lead_time_days)
UPDATE lead_time_cal l
JOIN t
ON t.product_id = l.product_id AND t.store_number = l.store_number
SET l.safety_stock = t.safety_stock;



select * from lead_time_cal;

-- Reorder Point Calculation 
-- ROP = (Average Daily Usage × Lead Time) + Safety Stock
ALTER TABLE lead_time_cal
ADD COLUMN reorder_point FLOAT;
WITH reorder_point_cal AS (
	SELECT 
		l.store_number,
        l.product_id,
        ROUND(((i.units_sold * l.avg_lead_time_days) + l.safety_stock),2) AS reorder_point
	FROM lead_time_cal l
    JOIN inventory i 
    ON l.store_number = i.store_number
    AND l.product_id = i.product_id
	)
UPDATE lead_time_cal l
JOIN reorder_point_cal r
ON l.store_number = r.store_number AND l.product_id = r.product_id
SET l.reorder_point = r.reorder_point;

SELECT * FROM lead_time_cal;




-- low inventory detection based on reorder point
ALTER TABLE lead_time_cal
DROP COLUMN stock_status ;

WITH t AS (
	SELECT 	
		l.store_number,
		l.product_id,
		CASE 
			WHEN i.inventory_level <= l.reorder_point THEN 'REORDER NOW'
			ELSE 'ENOUGH STOCK'
		END AS stock_status
	FROM lead_time_cal l
	JOIN inventory i
	ON l.store_number = i.store_number AND l.product_id = i.product_id)
SELECT * FROM t;

select * from 
lead_time_cal;



-- inventory turnover ration [TOTAL UNITS SOLD / AVG INVENTORY LEVEL]
-- (DOI)days of inventory. [365/ INVENTORY TURN OVER RATIO )]

ALTER TABLE lead_time_cal
ADD COLUMN inventory_turnover_ratio FLOAT,
ADD COLUMN day_of_inventory FLOAT;


WITH inventory_metrics AS (
  SELECT 
    product_id,
    store_number,
    ROUND(SUM(units_sold) / NULLIF(AVG(inventory_level), 0), 2) AS inventory_turnover_ratio,
    ROUND(365 / NULLIF(SUM(units_sold) / AVG(inventory_level), 0), 1) AS days_of_inventory
  FROM inventory
  GROUP BY product_id, store_number
)
UPDATE lead_time_cal l
JOIN inventory_metrics m
  ON l.product_id = m.product_id AND l.store_number = m.store_number
SET 
  l.inventory_turnover_ratio = m.inventory_turnover_ratio,
  l.day_of_inventory = m.days_of_inventory;
  
  
select * from 
lead_time_cal;




-- weekly slaes
SELECT 
    product_id,
    store_number,
    YEAR(date_) AS year,
    WEEK(date_, 1) AS week_number,  -- Mode 1: weeks start on Monday
    SUM(units_sold) AS weekly_sales
FROM inventory
GROUP BY product_id, store_number, YEAR(date_), WEEK(date_, 1)
ORDER BY year, week_number, product_id, store_number;



-- monthly sales
SELECT 
    product_id, 
    store_number,
    YEAR(date_) AS year,
    MONTH(date_) AS MONTH,  -- Mode 1: weeks start on Monday
    SUM(units_sold) AS monthly_sales
FROM inventory
GROUP BY product_id, store_number, YEAR(date_), month(date_)
ORDER BY year, month , product_id, store_number;



-- stock out rate

SELECT 
    product_id,
    store_number,

    -- Total forecasted demand days
    COUNT(CASE WHEN demand_forecast > 0 THEN 1 END) AS forecasted_demand_days,

    -- Days when stock was  less and forecasted demand existed
    COUNT(CASE WHEN inventory_level < demand_forecast  THEN 1 END) AS stockout_days,

    -- Stockout Rate
    ROUND(
        COUNT(CASE WHEN inventory_level < demand_forecast THEN 1 END) * 100.0 /
        NULLIF(COUNT(CASE WHEN demand_forecast > 0 THEN 1 END), 0), 2
    ) AS stockout_rate_percent

FROM inventory
GROUP BY product_id, store_number
ORDER BY stockout_rate_percent DESC;



-- revenue loss

SELECT 
    i.product_id,
    i.store_number,

    -- Sum of lost units where stock was unavailable and demand existed
    SUM(CASE 
        WHEN i.inventory_level < i.demand_forecast 
        THEN i.demand_forecast - i.inventory_level
        ELSE 0 
    END) AS lost_units,

    -- Total potential revenue lost
    ROUND(SUM(CASE 
        WHEN i.inventory_level < i.demand_forecast  
        THEN (i.demand_forecast - i.inventory_level)* s.price
        ELSE 0 
    END), 2) AS lost_revenue

FROM inventory i
JOIN pricing s ON i.order_id= s.order_id
GROUP BY i.product_id, i.store_number
ORDER BY lost_revenue DESC;




-- age of inventory ( AOI = average inventory level / avg units sold daily )
SELECT 
  product_id,
  store_number,
  ROUND(AVG(inventory_level), 2) AS avg_inventory,
  ROUND(AVG(units_sold), 2) AS avg_daily_sold,
  ROUND(AVG(inventory_level) / NULLIF(AVG(units_sold), 0), 2) AS inventory_age_days
FROM inventory
GROUP BY product_id, store_number;




ALTER TABLE lead_time_cal
ADD COLUMN last_day_stock_level_calculation FLOAT;
-- latest known inventory calculations
-- Finds the latest inventory record (max date) on or before 2024-12-30 for each product-store combo
WITH last_known_inventory AS (
  SELECT 
    store_number,
    product_id,
    MAX(date_) AS last_date
  FROM inventory
  WHERE date_ <= '2024-12-30'
  GROUP BY store_number, product_id
),
-- Retrieves the actual inventory details from inventory for that last known date (2024-12-30)
inventory_730_base AS (
  SELECT i.*
  FROM inventory i
  JOIN last_known_inventory l
    ON i.store_number = l.store_number 
   AND i.product_id = l.product_id
   AND i.date_ = l.last_date
),
-- Gets units sold on 2024-12-30 for each product-store
sales_730 AS (
  SELECT store_number, product_id, units_sold
  FROM inventory
  WHERE date_ = '2024-12-30'
),
-- Predicts deliveries expected to arrive on 2024-12-31
expected_deliveries_731 AS (
  SELECT 
    i.store_number,
    i.product_id,
    ROUND(SUM(i.units_order * 0.8), 0) AS expected_delivery
  FROM inventory i
  JOIN lead_time_cal p
    ON i.store_number = p.store_number AND i.product_id = p.product_id
  WHERE DATE_ADD(i.date_, INTERVAL p.avg_lead_time_days DAY) = '2024-12-31'
  GROUP BY i.store_number, i.product_id
),
-- calculation and join
final_731_inventory AS (
  SELECT 
    b.store_number,
    b.product_id,
    b.inventory_level
      - COALESCE(s.units_sold, 0)
      + COALESCE(e.expected_delivery, 0) AS inventory_731
  FROM inventory_730_base b
  LEFT JOIN sales_730 s
    ON b.store_number = s.store_number AND b.product_id = s.product_id
  LEFT JOIN expected_deliveries_731 e
    ON b.store_number = e.store_number AND b.product_id = e.product_id
)
UPDATE lead_time_cal p
JOIN final_731_inventory f
  ON p.store_number = f.store_number AND p.product_id = f.product_id
SET p.last_day_stock_level_calculation = f.inventory_731;



select * from lead_time_cal;






-- last date stock level calculation
ALTER TABLE lead_time_cal
ADD COLUMN last_day_stock_status BOOLEAN;

UPDATE lead_time_cal
SET last_day_stock_status = 
    CASE 
        WHEN reorder_point >= last_day_stock_level_calculation THEN 1
        ELSE 0
    END;


WITH base AS (
    SELECT product_id, store_number, inventory_turnover_ratio
    FROM lead_time_cal
    ORDER BY inventory_turnover_ratio DESC
    LIMIT 10
)
SELECT AVG(inventory_turnover_ratio) FROM base;




select * from lead_time_cal